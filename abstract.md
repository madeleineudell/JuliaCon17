Julia was designed to be the right language for programming mathematics. In this talk, I’ll argue that its sophisticated type system allows mathematicians to program in the same way they write mathematics. This simplicity has two consequences. First, it has made Julia an attractive ecosystem in which to write mathematical packages: Julia is now the language with the most comprehensive, robust, and user-friendly ecosystem of packages for mathematical programming (or optimization, in modern lingo). Second, it has made Julia the right language in which to express many mathematical problems. The lightweight type system makes it easy to write code that is clearer than pseudocode. This talk will present three case studies in optimization. We hope the audience will leave the talk with a new appreciation of Julia’s type system, as well as a new toolkit of packages to use for data fitting and optimization.

Convex is a widely used library for convex optimization in Julia. In that package, the type system is used to create and recursively analyze the abstract syntax tree representing an optimization problem. Notions such as the sign of a real number, or the convexity or concavity of a function, are represented as types; and the convexity of an expression can be analyzed using a simple recursion over the tree of types.

LowRankModels is a statistical package for imputing missing entries in large, heterogeneous tabular data set. LowRankModels uses type information about a DataFrame to automatically select the appropriate optimization problem to solve in order to find the best completion for the data table. These optimization problems are parametrized by a set of loss functions and regularizers. Using the type system, we are able to write algorithms that work seamlessly for any loss function or regularizer a user may dream up.

Sketched approximations are a class of fast algorithms for producing a low rank approximation to a matrix - like an eigenvalue decomposition, but faster. We’ll show how to use parametric types to write all the special cases of the algorithm without introducing redundant code. Notably, these parametric types make it easier to understand the flow of the algorithm, and have essentially no analogue in “pseudocode” notation. Together with Julia’s simple mathematical syntax and support for unicode (eg, Greek) letters, we’ll see that the Julia code functions not only as an implementation of the method, but as a better version of pseudocode.
